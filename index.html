<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WEB X — Prototype Particules Humanoïde</title>
  <style>
    html,body {height:100%; margin:0; background:#0b0c10; color:#cfd8e3; font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;}
    canvas { display:block; }
    .ui {
      position: fixed; inset: 0 auto auto 0; padding: 10px 14px;
      background: linear-gradient(90deg, rgba(10,10,14,.8), rgba(10,10,14,0));
      border-bottom-right-radius: 12px; backdrop-filter: blur(6px);
      font-size: 14px; color:#cbd5e1; z-index:10;
    }
    .ui b { color:#f8fafc }
    .progress {
      position: fixed; right: 12px; bottom: 12px;
      width: 160px; height: 6px; background: #1f2937; border-radius: 999px; overflow: hidden;
      box-shadow: 0 0 0 1px rgba(255,255,255,.06) inset;
    }
    .progress > i { display:block; height:100%; width: 0%; background: linear-gradient(90deg,#ffd56a,#ff9f2e,#ff6b00); }
    section {height:120vh; display:flex; align-items:end; justify-content:center;}
    .blk {max-width:820px; padding: 40px 20px 80px;}
    h1 {font-size: clamp(28px, 6vw, 64px); line-height:1.06; margin: 0 0 12px; background: linear-gradient(90deg,#c8d7ff,#b8b8ff,#d2a7ff); -webkit-background-clip:text; -webkit-text-fill-color:transparent;}
    p {opacity:.84; font-size: clamp(16px,2.5vw,18px);}
  </style>
</head>
<body>
  <div class="ui">Défilez pour morph <b>Énergie ⇄ Humanoïde</b></div>
  <div class="progress"><i id="bar"></i></div>
  <section></section>
  <section><div class="blk"><h1>Des sites 3D & immersifs</h1><p>Prototype — Particules dorées se rassemblant en silhouette humanoïde, puis se diffusant à nouveau en énergie, synchronisées au scroll.</p></div></section>
  <section><div class="blk"><p>Ce bloc sert juste à donner de la hauteur pour scroller et tester. Nous brancherons ensuite la scène au héros de votre page.</p></div></section>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js';

    // —— Scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0c10, 30, 120);
    const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 500);
    camera.position.set(0, 1.2, 7);
    const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.enabled = false; // activer pour debug

    // —— Lights (subtle to keep particles visible)
    const key = new THREE.PointLight(0xffcc66, 2, 30); key.position.set(4,6,6); scene.add(key);
    const rim = new THREE.PointLight(0xff8800, 2, 30); rim.position.set(-6,4,-6); scene.add(rim);
    scene.add(new THREE.AmbientLight(0x332211, 0.6));

    // —— Particle system
    const COUNT = 28000;
    const positionsStart = new Float32Array(COUNT*3);
    const positionsHuman = new Float32Array(COUNT*3);
    const noiseOffsets = new Float32Array(COUNT*3);
    const tmp = new THREE.Vector3();

    // Start cloud (energy): sphere + noise
    function rand(min,max){return Math.random()*(max-min)+min}
    for(let i=0;i<COUNT;i++){
      // random on sphere radius 3
      let u = Math.random(), v = Math.random();
      const theta = 2*Math.PI*u, phi = Math.acos(2*v-1);
      const r = 3.0 * (0.65 + Math.random()*0.35);
      const x = r*Math.sin(phi)*Math.cos(theta);
      const y = r*Math.cos(phi);
      const z = r*Math.sin(phi)*Math.sin(theta);
      positionsStart[i*3+0]=x; positionsStart[i*3+1]=y; positionsStart[i*3+2]=z;
      noiseOffsets[i*3+0]=rand(-100,100); noiseOffsets[i*3+1]=rand(-100,100); noiseOffsets[i*3+2]=rand(-100,100);
    }

    // Target "human" made from union of simple volumes (spheres + capsules)
    // Coordinate system: Y up, height ~ 3 units
    const parts = [];
    // Head (sphere)
    parts.push({type:'sphere', c:new THREE.Vector3(0,1.6,0), r:0.45, density:1.0});
    // Neck (capsule)
    parts.push({type:'capsule', a:new THREE.Vector3(0,1.2,0), b:new THREE.Vector3(0,1.6,0), r:0.18, density:0.7});
    // Torso (capsule)
    parts.push({type:'capsule', a:new THREE.Vector3(0,0.2,0), b:new THREE.Vector3(0,1.2,0), r:0.45, density:1.1});
    // Pelvis (sphere-ish)
    parts.push({type:'sphere', c:new THREE.Vector3(0,0.0,0), r:0.35, density:0.9});
    // Arms (capsules)
    parts.push({type:'capsule', a:new THREE.Vector3(0.45,1.05,0), b:new THREE.Vector3(0.85,0.5,0), r:0.16, density:0.8}); // right upper
    parts.push({type:'capsule', a:new THREE.Vector3(0.85,0.5,0), b:new THREE.Vector3(0.85,0.0,0), r:0.14, density:0.8}); // right fore
    parts.push({type:'capsule', a:new THREE.Vector3(-0.45,1.05,0), b:new THREE.Vector3(-0.85,0.5,0), r:0.16, density:0.8}); // left upper
    parts.push({type:'capsule', a:new THREE.Vector3(-0.85,0.5,0), b:new THREE.Vector3(-0.85,0.0,0), r:0.14, density:0.8}); // left fore
    // Legs (capsules)
    parts.push({type:'capsule', a:new THREE.Vector3(0.22,-0.1,0), b:new THREE.Vector3(0.22,-1.3,0), r:0.2, density:1.0});
    parts.push({type:'capsule', a:new THREE.Vector3(-0.22,-0.1,0), b:new THREE.Vector3(-0.22,-1.3,0), r:0.2, density:1.0});

    function randOnSphere(r){
      const u=Math.random(), v=Math.random();
      const th=2*Math.PI*u, ph=Math.acos(2*v-1);
      return new THREE.Vector3(
        r*Math.sin(ph)*Math.cos(th),
        r*Math.cos(ph),
        r*Math.sin(ph)*Math.sin(th)
      );
    }
    function sampleCapsule(a,b,r){
      // blend between line AB and radial offset
      const t = Math.random();
      const p = a.clone().lerp(b, t);
      const off = randOnSphere(r*(0.7+0.3*Math.random()));
      return p.add(off);
    }
    function samplePart(part){
      if(part.type==='sphere'){
        return part.c.clone().add(randOnSphere(part.r*(0.7+0.3*Math.random())));
      } else {
        return sampleCapsule(part.a, part.b, part.r);
      }
    }

    // Fill human targets
    for(let i=0;i<COUNT;i++){
      // weighted random pick part by "density"
      const total = parts.reduce((s,p)=>s+(p.density||1),0);
      let pick = Math.random()*total, chosen = parts[0];
      for(const p of parts){ pick -= (p.density||1); if(pick<=0){ chosen=p; break; } }
      const v = samplePart(chosen);
      // slight asym & breathing arc
      v.z += (Math.sin(v.y*2.5)*0.10);
      positionsHuman[i*3+0]=v.x; positionsHuman[i*3+1]=v.y; positionsHuman[i*3+2]=v.z;
    }

    // Geometry & material
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positionsStart.slice(), 3));
    const sizes = new Float32Array(COUNT);
    for(let i=0;i<COUNT;i++){ sizes[i] = Math.random()*1.6 + 0.9; }
    geom.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));

    // Create a small soft-circle sprite via canvas (no external textures)
    const spriteCanvas = document.createElement('canvas'); spriteCanvas.width=spriteCanvas.height=64;
    const ctx = spriteCanvas.getContext('2d');
    const grd = ctx.createRadialGradient(32,32,0, 32,32,32);
    grd.addColorStop(0,'rgba(255,200,80,1)');
    grd.addColorStop(0.35,'rgba(255,160,40,0.85)');
    grd.addColorStop(1,'rgba(255,120,0,0)');
    ctx.fillStyle = grd; ctx.fillRect(0,0,64,64);
    const map = new THREE.CanvasTexture(spriteCanvas);

    const mat = new THREE.PointsMaterial({
      size: 0.055, map, transparent:true, depthWrite:false,
      blending: THREE.AdditiveBlending, color: 0xffbb66, opacity: 0.95, sizeAttenuation:true
    });

    const points = new THREE.Points(geom, mat);
    scene.add(points);

    // ——— Scroll mapping 0..1
    let scrollProg = 0;
    const bar = document.getElementById('bar');
    function onScroll(){
      const h = document.documentElement.scrollHeight - innerHeight;
      scrollProg = h>0 ? window.scrollY / h : 0;
      bar.style.width = (scrollProg*100).toFixed(1)+'%';
    }
    window.addEventListener('scroll', onScroll, {passive:true}); onScroll();

    // ——— Animation
    const pos = geom.getAttribute('position');
    function perlin3(x,y,z){
      // tiny pseudo-noise
      return Math.sin(x*1.3 + Math.cos(y*1.7) + z*1.1)*0.5 + Math.sin(y*2.2 + z*1.9)*0.35;
    }

    const clock = new THREE.Clock();
    function animate(){
      const t = clock.getElapsedTime();
      // morph factor shaped for nicer build-up
      const morph = Math.min(1, Math.max(0, scrollProg));
      const ease = morph<0.5 ? (2*morph*morph) : (1 - Math.pow(-2*morph+2,2)/2);

      for(let i=0;i<COUNT;i++){
        const i3=i*3;
        const sx = positionsStart[i3+0], sy = positionsStart[i3+1], sz = positionsStart[i3+2];
        const hx = positionsHuman[i3+0], hy = positionsHuman[i3+1], hz = positionsHuman[i3+2];
        // interpolate
        let x = sx*(1-ease) + hx*ease;
        let y = sy*(1-ease) + hy*ease;
        let z = sz*(1-ease) + hz*ease;
        // energy jitter
        const n = perlin3(x*0.6+noiseOffsets[i3+0], y*0.6+noiseOffsets[i3+1], z*0.6+noiseOffsets[i3+2]);
        const amp = (1-ease)*0.8 + 0.05;
        x += Math.sin(t*1.6 + n*6.283)*amp*0.25;
        y += Math.cos(t*1.3 + n*6.283)*amp*0.22;
        z += Math.sin(t*1.7 + n*6.283)*amp*0.25;
        pos.array[i3+0]=x; pos.array[i3+1]=y; pos.array[i3+2]=z;
      }
      pos.needsUpdate = true;

      // subtle auto camera drift
      camera.position.x = Math.sin(t*0.15)*1.2;
      camera.position.y = 1.2 + Math.sin(t*0.1)*0.1;
      camera.lookAt(0,0.8,0);

      controls.update();
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();

    // Resize
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
